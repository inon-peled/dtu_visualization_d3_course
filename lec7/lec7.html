<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Lec7</title>
    <script type="text/javascript" src="./d3.js"></script>
    <script type="text/javascript" src="./lodash.js"></script>
    <style type="text/css">
        .murderLocation {
            fill: lightgrey;
            stroke: black;
            stroke-width: 1;
            opacity: 1;
        }
    </style>
</head>
<body>
<script type="text/javascript">
    // var noGlobalsLec7 = function() { // No global variables
    var daily_murder_count = null;
    var all_murder = null;
    var projection;

    var createAllCircles = function() {
        d3.select("#svgMap")
            .selectAll("circle")
            .data(all_murder, function (d) { return d.complnt_num; })
            .enter()
            .append("circle")
            .attr("class", "murderLocation nonBrushed")
            .attr("cx", function (d) {
                return projection([d.lon, d.lat])[0];
            })
            .attr("cy", function (d) {
                return projection([d.lon, d.lat])[1];
            })
            .attr("r", 4);
    };

    var placeCircles = function (brushSelection, xTimeline, svgTimelineMargin) {
        var murdersInBrushedTimeline = brushSelection === null ?
            _.map(all_murder, function (d) { return _.assign(d, { selected: true });}) :
            _.map(all_murder, function (d) {
                var fromDate = xTimeline.invert(brushSelection[0] - svgTimelineMargin.left);
                var toDate = xTimeline.invert(brushSelection[1] - svgTimelineMargin.left);
                return _.assign(d, { selected: (d.date >= fromDate) && (d.date <= toDate) });
            });
        d3.selectAll(".murderLocation")
            .data(murdersInBrushedTimeline, function (d) { return d.murder_id; })
            .attr("r", function (d) { return d.selected ? 4 : 0 });
    };

    var createTimeline = function () {
        d3.csv("all_murder.csv",
            function (d) {
                return {
                    murder_id: d.INDEX,
                    lat: parseFloat(d.Latitude),
                    lon: parseFloat(d.Longitude),
                    hour: parseInt(d.CMPLNT_FR_TM),
                    borough: d.BORO_NM,
                    date_str: d.RPT_DT,
                    date: d3.timeParse("%m/%d/%Y")(d.RPT_DT)
                };
            },
            function (data) {
                all_murder = _(data).filter(function (d) { return !_.isNaN(d.lat); }).sortBy("date").value();
                daily_murder_count = _.map(d3.nest()
                        .key(function (d) {
                            return d.date_str;
                        })
                        .rollup(function (v) {
                            return v.length;
                        })
                        .entries(all_murder),
                    function (d) {
                        return {
                            date: d3.timeParse("%m/%d/%Y")(d.key),
                            value: d.value
                        };
                    });
                createAllCircles();

                var svgTimelineMargin = {top: 20, right: 20, bottom: 30, left: 50};
                var svgTimelineWidth = 1200;
                var svgTimelineHeight = 150;
                var svgTimeline = d3.select("body")
                    .append("svg")
                    .attr("width", svgTimelineWidth + svgTimelineMargin.left + svgTimelineMargin.right)
                    .attr("height", svgTimelineHeight + svgTimelineMargin.top + svgTimelineMargin.bottom);
                var g = svgTimeline.append("g")
                    .attr("transform", "translate(" + svgTimelineMargin.left + "," + svgTimelineMargin.top + ")");

                var xTimeline = d3.scaleTime()
                    .rangeRound([0, svgTimelineWidth]);
                var yTimeline = d3.scaleLinear()
                    .rangeRound([svgTimelineHeight, 0]);

                var line = d3.line()
                    .x(function (d) {
                        return xTimeline(d.date);
                    })
                    .y(function (d) {
                        return yTimeline(d.value);
                    });

                xTimeline.domain(d3.extent(daily_murder_count, function (d) {
                    return d.date;
                }));
                yTimeline.domain(d3.extent(daily_murder_count, function (d) {
                    return d.value;
                }));

                g.append("g")
                    .attr("transform", "translate(0, " + (svgTimelineHeight + svgTimelineMargin.bottom / 3) + ")")
                    .call(d3.axisBottom(xTimeline));

                g.append("g")
                    .attr("transform", "translate(" + (-svgTimelineMargin.left / 4) + ", 0)")
                    .call(d3.axisLeft(yTimeline))
                    .append("text")
                    .attr("fill", "#000")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", "0.71em")
                    .attr("text-anchor", "end")
                    .text("#Murders");

                g.append("path")
                    .datum(daily_murder_count)
                    .attr("fill", "none")
                    .attr("stroke", "red")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-linecap", "round")
                    .attr("stroke-width", 1.5)
                    .attr("d", line);

                var brushTimeline = d3.brushX()
                    .extent([
                        [svgTimelineMargin.left, svgTimelineMargin.top - 3],
                        [svgTimelineWidth + svgTimelineMargin.left, svgTimelineHeight + svgTimelineMargin.top + 3]])
                    .on("brush", function () {
                        if (d3.event.selection != null) {
                            placeCircles(d3.brushSelection(this), xTimeline, svgTimelineMargin);
                        }
                    })
                    .on("end", function () {
                        if (d3.brushSelection(this) === null) {
                            placeCircles(null);
                        }
                    });

                // create svg group with class brush and call brush on it
                var brushGroupTimeline = svgTimeline.append("g")
                    .attr("class", "brush")
                    .call(brushTimeline);

                // set brush extent to rect and define objects height
                brushGroupTimeline.selectAll("rect")
                    .attr("height", svgTimelineHeight);
            });
    };

    var createMap = function() {
        var svgMapResizeFactor = 1.5;
        var svgMapWidth = 600 * svgMapResizeFactor;
        var svgMapHeight = 400 * svgMapResizeFactor;
        var boroughColors = d3.scaleOrdinal(d3.schemeCategory10);

        projection = d3.geoMercator()
            .center([-74.0, 40.7]) // Approximate center point of NYC.
            .translate([svgMapWidth / 2, svgMapHeight / 2])
            .scale([100000 * 0.6]);

        var path = d3.geoPath()
            .projection(projection);

        var svgMap = d3.select("body")
            .append("svg")
            .attr("id", "svgMap")
            .attr("width", svgMapWidth)
            .attr("height", svgMapHeight);

        d3.json("boroughs.geojson", function (json) {
            //Bind data and create one path per GeoJSON feature
            svgMap.selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", function (d, i) {
                    return boroughColors(i);
                });
            createTimeline();
        });
    }();
</script>

</body>
</html>