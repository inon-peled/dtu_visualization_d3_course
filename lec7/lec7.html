<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Lec7</title>
    <script type="text/javascript" src="./d3.js"></script>
    <script type="text/javascript" src="./lodash.js"></script>
    <style type="text/css">
        .animateButton rect {
            fill: black;
            opacity: 0.2;
            rx: 5;
            ry: 5;
        }

        .animateButton text {
            fill: black;
            font-size: 18px;
            text-anchor: middle;
        }
        .animateButton:hover rect,
        .animateButton:hover text {
            fill: blue;
        }
        .murderLocation {
            fill: lightgrey;
            stroke: black;
            stroke-width: 1;
            opacity: 1;
        }
    </style>
</head>
<body>

<p>Note that we display only murders for which the date, hour, and location are all known.</p>

<script type="text/javascript">
    // var noGlobalsLec7 = function() { // No global variables
    var daily_murder_count = null;
    var all_murder = null;
    var projection;
    var svgMapWidth;
    var xTimeline;
    var svgTimelineMargin;
    var svgTimeline;
    var svgTimelineWidth = 1200;
    var svgTimelineHeight = 120;

    var dateToNiceStr = function(date) {
        var MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return date.getDate() +
            '-' + MONTH_NAMES[date.getMonth()] +
            "-" + date.getFullYear();
    };

    var createAllCircles = function() {
        d3.select("#svgMap")
            .selectAll("circle")
            .data(all_murder, function (d) { return d.murder_id; })
            .enter()
            .append("circle")
            .attr("class", "murderLocation nonBrushed")
            .attr("cx", function (d) {
                return projection([d.lon, d.lat])[0];
            })
            .attr("cy", function (d) {
                return projection([d.lon, d.lat])[1];
            })
            .append("title")
            .text(function(d) { return dateToNiceStr(d.date) +
                ", " + d.hour + " hr, " +
                _.startCase(_.toLower(d.borough)); });
        placeCircles(null);
    };

    var placeCircles = function (brushSelection, callback) {
        var fromDate = brushSelection === null ?
            _.first(all_murder).date :
            xTimeline.invert(brushSelection[0] - svgTimelineMargin.left);
        var toDate = brushSelection === null ?
            _.last(all_murder).date :
            xTimeline.invert(brushSelection[1] - svgTimelineMargin.left);
        var murdersSelected = _.map(all_murder, function (d) {
            return _.assign(d, { selected: (d.date >= fromDate) && (d.date <= toDate) });
        });
        d3.select("#timelineTitle")
            .text(dateToNiceStr(fromDate) + " to " + dateToNiceStr(toDate) +
                " (" + _.filter(murdersSelected, function (d) { return d.selected === true; }).length + " Murders)");
        d3.selectAll(".murderLocation")
            .data(murdersSelected, function (d) { return d.murder_id; })
            .attr("r", function (d) { return d.selected ? 4 : 0 });
        if (callback) {
            callback();
        }
    };

    var createTimeline = function () {
        d3.csv("all_murder.csv",
            function (d) {
                return {
                    murder_id: d.INDEX,
                    lat: parseFloat(d.Latitude),
                    lon: parseFloat(d.Longitude),
                    hour: parseInt(d.CMPLNT_FR_TM),
                    borough: d.BORO_NM,
                    date_str: d.RPT_DT,
                    date: d3.timeParse("%m/%d/%Y")(d.RPT_DT)
                };
            },
            function (data) {
                all_murder = _(data)
                    .filter(function (d) { return !_.some(_.map(_.values(d), _.isNaN)) })
                    .sortBy("date")
                    .value();
                daily_murder_count = _.map(d3.nest()
                        .key(function (d) {
                            return d.date_str;
                        })
                        .rollup(function (v) {
                            return v.length;
                        })
                        .entries(all_murder),
                    function (d) {
                        return {
                            date: d3.timeParse("%m/%d/%Y")(d.key),
                            value: d.value
                        };
                    });
                createAllCircles();

                svgTimelineMargin = {top: 60, right: 20, bottom: 30, left: 50};
                svgTimeline = d3.select("body")
                    .append("svg")
                    .attr("width", svgTimelineWidth + svgTimelineMargin.left + svgTimelineMargin.right)
                    .attr("height", svgTimelineHeight + svgTimelineMargin.top + svgTimelineMargin.bottom);
                var g = svgTimeline.append("g")
                    .attr("transform", "translate(" + svgTimelineMargin.left + "," + svgTimelineMargin.top + ")");

                d3.select("#svgMap")
                    .append("text")
                    .attr("id", "timelineTitle")
                    .attr("x", svgMapWidth / 12)
                    .attr("y", 75)
                    .style("font-size", 24)
                    .text(dateToNiceStr(_.first(all_murder).date) + " to " + dateToNiceStr(_.last(all_murder).date) +
                        " (" + all_murder.length + " Murders)");

                xTimeline = d3.scaleTime()
                    .rangeRound([0, svgTimelineWidth]);
                var yTimeline = d3.scaleLinear()
                    .rangeRound([svgTimelineHeight, 0]);

                var line = d3.line()
                    .x(function (d) {
                        return xTimeline(d.date);
                    })
                    .y(function (d) {
                        return yTimeline(d.value);
                    });

                xTimeline.domain(d3.extent(daily_murder_count, function (d) {
                    return d.date;
                }));
                yTimeline.domain(d3.extent(daily_murder_count, function (d) {
                    return d.value;
                }));

                g.append("g")
                    .attr("transform", "translate(0, " + (svgTimelineHeight + svgTimelineMargin.bottom / 3) + ")")
                    .call(d3.axisBottom(xTimeline));

                g.append("g")
                    .attr("transform", "translate(" + (-svgTimelineMargin.left / 4) + ", 0)")
                    .call(d3.axisLeft(yTimeline))
                    .append("text")
                    .attr("fill", "#000")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", "0.71em")
                    .attr("text-anchor", "end")
                    .text("#Murders");

                g.append("path")
                    .datum(daily_murder_count)
                    .attr("fill", "none")
                    .attr("stroke", "red")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-linecap", "round")
                    .attr("stroke-width", 1.5)
                    .attr("d", line);

                var brushTimeline = d3.brushX()
                    .extent([
                        [svgTimelineMargin.left, svgTimelineMargin.top - 3],
                        [svgTimelineWidth + svgTimelineMargin.left, svgTimelineHeight + svgTimelineMargin.top + 3]])
                    .on("brush", function () {
                        if (d3.event.selection != null) {
                            placeCircles(d3.brushSelection(this), xTimeline, svgTimelineMargin);
                        }
                    })
                    .on("end", function () {
                        if (d3.brushSelection(this) === null) {
                            placeCircles(null);
                        }
                    });

                // create svg group with class brush and call brush on it
                var brushGroupTimeline = svgTimeline.append("g")
                    .attr("id", "brushGroupTimeline")
                    .attr("class", "brush")
                    .call(brushTimeline);

                // set brush extent to rect and define objects height
                brushGroupTimeline.selectAll("rect")
                    .attr("height", svgTimelineHeight);

                // Animate
                var animateButton = svgTimeline.append("g")
                    .attr("class", "animateButton")
                    .attr("transform", "translate(" + (svgTimelineWidth / 2) + "," + 0 + ")");

                animateButton.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 80)
                    .attr("height", 30);

                animateButton.append("text")
                    .attr("id", "animateText")
                    .attr("x", 40)
                    .attr("y", 20)
                    .text("Animate!");

                var stepSize = 30;
                var step = function() {
                    var selectionWidth = parseInt(brushGroupTimeline.select(".selection").attr("width"));
                    var newStartX = parseInt(brushGroupTimeline.select(".selection").attr("x")) + stepSize;
                    var newEndX = newStartX + selectionWidth;
                    if (newEndX <= svgTimelineWidth + svgTimelineMargin.left) {
                        brushGroupTimeline.select(".selection")
                            .transition()
                            .ease(d3.easeLinear)
                            .attr("x", newStartX)
                            .on("end", function() {
                                placeCircles([newStartX, newEndX], step);
                            });
                    } else {
                        var finalStartX = svgTimelineWidth + svgTimelineMargin.left - selectionWidth;
                        brushGroupTimeline.select(".selection").transition().attr("x", finalStartX);
                        placeCircles([finalStartX, finalStartX + selectionWidth]);
                    }
                };

                animateButton.on("click", function() {
                    brushGroupTimeline.select(".selection").attr("x", 0);
                    brushGroupTimeline.select(".selection").attr("width", stepSize * 2);
                    step();
                });

            });
    };

    var createMap = function() {
        var svgMapResizeFactor = 1.5;
        svgMapWidth = 800 * svgMapResizeFactor;
        var svgMapHeight = 400 * svgMapResizeFactor;
        var boroughColors = d3.scaleOrdinal(d3.schemeCategory10);

        projection = d3.geoMercator()
            .center([-74.0, 40.7]) // Approximate center point of NYC.
            .translate([svgMapWidth / 2, svgMapHeight / 2])
            .scale([100000 * 0.6]);

        var path = d3.geoPath()
            .projection(projection);

        var svgMap = d3.select("body")
            .append("svg")
            .attr("id", "svgMap")
            .attr("width", svgMapWidth)
            .attr("height", svgMapHeight);

        d3.json("boroughs.geojson", function (json) {
            //Bind data and create one path per GeoJSON feature
            svgMap.selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", function (d, i) {
                    return boroughColors(i);
                });
            createTimeline();
        });
    }();
</script>

</body>
</html>