<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Lec6</title>
    <script type="text/javascript" src="./d3.js"></script>
    <script type="text/javascript" src="./lodash.js"></script>
    <style type="text/css">
        .brushed {
            fill: yellow;
            stroke: grey;
            stroke-width: 1.5;
            opacity: 1;
        }
        .nonBrushed {
            fill: lightgrey;
            stroke: black;
            stroke-width: 1;
            opacity: 1;
        }
    </style>
</head>
<body>
<script type="text/javascript">
    var murderPerHour = function(selectedCircles) {
        return _.reduce(
            selectedCircles.data(),
            function (counts, d) {
                counts[d.hour] += 1;
                return counts;
            },
            _.fromPairs(_.map(_.range(24), function (h) { return [h, 0] }))
        );
    };

    //Width and height
    var svgResizeFactor = 1.5;
    var svgWiodth = 600 * svgResizeFactor;
    var svgHeight = 400 * svgResizeFactor;
    var murders = [];
    var boroughColors= d3.scaleOrdinal(d3.schemeCategory10);

    //Define map projection
    var projection = d3.geoMercator()
        .center([-74.0, 40.7]) // Approximate center point of NYC.
        .translate([svgWiodth / 2, svgHeight / 2])
        .scale([100000 * 0.6]);

    //Define path generator
    var path = d3.geoPath()
        .projection(projection);

    //Create SVG element
    var svg = d3.select("body")
        .append("svg")
        .attr("width", svgWiodth)
        .attr("height", svgHeight);

    //Load in GeoJSON data
    d3.json("boroughs.geojson", function (json) {
        //Bind data and create one path per GeoJSON feature
        svg.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", path)
            .style("fill", function (d, i) {
                return boroughColors(i);
            });
        // Place circles for murder occurences in 2016.
        d3.csv("murders_2016.csv",
            function (d) {
                return {
                    "lat": parseFloat(d.Latitude),
                    "lon": parseFloat(d.Longitude),
                    "hour": parseInt(d.HR)
                };
            },
            function (data) {
                murders = _.filter(data, function (d) { return !_.isNaN(d.lat); });
                svg.selectAll("circle")
                    .data(murders)
                    .enter()
                    .append("circle")
                    .attr("class", "murderLocation nonBrushed")
                    .attr("cx", function(d) {
                        return projection([d.lon, d.lat])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d.lon, d.lat])[1];
                    })
                    .attr("r", 0)
                    .transition()
                    .duration(400)
                    .attr("r", 30)
                    .transition()
                    .duration(600)
                    .attr("r", 5);
            });
    });

    var brush = d3.brush()
        .on("brush", function () {
            if (d3.event.selection != null) {
                // revert circles to initial style
                d3.selectAll(".murderLocation")
                    .attr("class", "murderLocation nonBrushed");

                var brush_coords = d3.brushSelection(this);

                // style brushed circles
                d3.selectAll(".murderLocation").filter(function (){
                    var cx = d3.select(this).attr("cx"),
                        cy = d3.select(this).attr("cy");

                    function isBrushed(brush_coords, cx, cy) {

                        var x0 = brush_coords[0][0],
                            x1 = brush_coords[1][0],
                            y0 = brush_coords[0][1],
                            y1 = brush_coords[1][1];

                        return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
                    }

                    return isBrushed(brush_coords, cx, cy);
                })
                    .attr("class", "murderLocation brushed");
                console.log(murderPerHour(d3.selectAll(".brushed")));
            }
        })
        .on("end", function() {
            if (!d3.event.selection) return;
            d3.select(this).call(brush.move, null);
        });
    svg.append("g")
        .call(brush);

    svg.on("click", function() {
        d3.selectAll(".murderLocation")
            .attr("class", "murderLocation nonBrushed");
    });

//    TODO: 1) select all by default, 2) select all button, 3) legend of boroughs.
    // TODO: 4) instructions in text about what you can do with the interactive plot.
    // TODO: 5) Total count. 6) Stacked bar plot with rects colored by borrough. Use online code examples.

</script>

<script type="text/javascript">
    var barplotAxisPadding = 60;
    var barplotSvgWidth = 800;
    var barplotSvgHeight = 500;

    var dataset = [
        [0, 0, 0, 0, 0, 1, 7, 8, 10, 5, 0, 0],
        [2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2],
        [0, 0, 0, 2, 11, 16, 23, 28, 33, 31, 11, 3],
        [9, 9, 6, 3, 3, 3, 2, 1, 0, 0, 6, 8]
    ];

    var barColors = [
        'red',
        'pink',
        'blue',
        'lightblue'
    ];

    var xLabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    var xScale = d3
        .scaleBand()
        .domain(d3.range(xLabels.length))
        .rangeRound([barplotAxisPadding, barplotSvgWidth])
        .paddingInner(0.05);
    var yScale = d3.scaleLinear();
    var yScaleRev = d3.scaleLinear();

    var svgBarplot = d3
        .select("#interactive1")
        .append("svg")
        .attr("class", "interactive")
        .attr("width", barplotSvgWidth)
        .attr("height", barplotSvgHeight);

    var xAxis = d3
        .axisBottom(xScale)
        .tickFormat(function (d, i) {
            return xLabels[i];
        });
    var yAxis = d3
        .axisLeft(yScaleRev)
        .tickFormat(function (e) {
            return Math.floor(e) !== e ? "" : e;
        });

    var refreshPlot = function (dataset, idx) {
        yScale
            .domain([1 + d3.max(dataset[idx]), 0]);
        yScaleRev
            .domain([1 + d3.max(dataset[idx]), 0]);
        svgBarplot
            .selectAll(".bar")
            .data(dataset[idx])
            .transition()
            .attr("y", function (d) {
                return barplotSvgHeight - yScale(d);
            })
            .attr("height", function (d) {
                return yScale(d) - barplotAxisPadding;
            })
            .attr("fill", barColors[idx]);
        svgBarplot
            .selectAll(".barLabel")
            .data(dataset[idx])
            .transition()
            .attr("y", function (d) {
                return yScaleRev(d) - 10;
            })
            .text(function (d) {
                return d;
            });
        svgBarplot.select(".yAxis")
            .transition()
            .call(yAxis);
    };

    var initializePlot = function (dataset, idx) {
        console.log("HERE")
        yScale
            .range([barplotSvgHeight - barplotAxisPadding, barplotAxisPadding]);
        yScaleRev
            .range([barplotAxisPadding, barplotSvgHeight - barplotAxisPadding]);
        svgBarplot
            .selectAll("rect")
            .data(dataset[idx])
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", function (d, i) {
                return xScale(i);
            })
            .attr("width", xScale.bandwidth());
        svgBarplot.selectAll("text")
            .data(dataset[idx])
            .enter()
            .append("text")
            .attr("class", "barLabel")
            .attr("x", function (d, i) {
                return xScale(i) + xScale.bandwidth() / 2;
            })
            .attr("text-anchor", "middle")
            .attr("font-family", "sans-serif")
            .attr("font-size", 16  + "px");
        svgBarplot.append("g")
            .attr("class", "xAxis")
            .attr("transform", "translate(0, " + (barplotSvgHeight - barplotAxisPadding) + ")")
            .call(xAxis);
        svgBarplot.append("g")
            .attr("class", "yAxis")
            .attr("transform", "translate(" + barplotAxisPadding + ", 0)")
            .call(yAxis);

        svgBarplot.append("text")
            .attr("x", barplotSvgWidth / 2)
            .attr("y", barplotAxisPadding / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "22px")
            .text("NYC Green Markets: Unique Produce Types");
        svgBarplot.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0)
            .attr("x", -barplotSvgHeight / 2)
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("No. Unique Types of Produce");
        svgBarplot.append("text")
            .attr("y", barplotSvgHeight - barplotAxisPadding / 2)
            .attr("x", barplotSvgWidth / 2)
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Month");

        refreshPlot(dataset, idx);
    };

    initializePlot(dataset, 0);

    d3
        .select("#whatToDisplay")
        .on("change", function () {
            refreshPlot(dataset, d3.select("#whatToDisplay").property("value"));
        });
</script>

</body>
</html>